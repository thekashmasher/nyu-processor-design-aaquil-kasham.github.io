
# Aaquils’s Design Notebook

**NYU Processor Design — Onboarding Labs & Project Reflections**

---

## Week of 22 September 2025 (Week 4)
## Weeks of September 1 – September 22, 2025

Project Work:
- Reviewed course slides and processor design documentation provided on the NYU Processor Design website.
- Completed the “Design Notebooks and Git” and “Development Environment” setup guides.
- Read through the RISC-16 reference materials and example implementations to understand the overall architecture.
- Familiarized myself with the group repository structure and existing starter code.

Progress Notes:
During the first few weeks, my focus was on getting up to speed with the tools, workflow, and overall processor architecture. I spent time going through lecture slides and online documentation to understand how the Program Counter, register file, ALU, and memory modules are expected to interact. This helped clarify design expectations before writing any Verilog.

I also set up my local development environment and practiced running simple testbenches to ensure my toolchain was working correctly. Reviewing reference designs early on helped me better understand how control flow and datapath components fit together at a high level.

---

## Onboarding Labs — Required Notes & Answers

---

## Lab 1 — CMake and Toolchain
### CMake Version

The CMake version used was obtained with:

```bash
cmake --version
```
---

### Path Resolution in `target_sources()` and `target_include_directories()`

All paths passed to `target_sources()` and `target_include_directories()` are **relative to the directory containing the `CMakeLists.txt` file**, not the build directory.

This design allows builds to be run from any location without modifying source paths and supports out-of-tree builds.

---

### CMake vs Ninja

**CMake**

* A meta-build system
* Generates build files (Makefiles, Ninja files, etc.)
* Describes project structure, dependencies, and targets
* Does not perform compilation itself

**Ninja**

* A low-level build system
* Executes compilation and linking steps
* Extremely fast but not human-readable
* Intended to be generated by tools like CMake

### Why Use a Separate `build/` Directory?

Using a dedicated build directory:

1. Keeps generated files out of the source tree
2. Allows multiple configurations (Debug, Release)
3. Makes cleanup trivial (`rm -rf build`)
4. Reflects industry-standard practice

### `make help` Targets

* `all`: Builds all default targets
* `clean`: Removes compiled outputs
* Project-specific targets (e.g., `hello_world`) build individual executables or libraries

---

## Lab 2 — SystemVerilog
Lab 2 can be found here:https://github.com/thekashmasher/onboarding-lab2/tree/main/dv
### Exercise 1 Testing Strategy

Exhaustive testing is used because:

* The input space is small
* The logic is purely combinational
* All possible input combinations can be tested efficiently

---

### Exercise 2 Testing Strategy

Sampling-based testing is used because:

* The LFSR has a very large internal state space
* Exhaustive testing is infeasible
* Running many sampled initial states over many cycles provides high confidence in correctness

---

### Exercise 3 Testing Strategy

Randomized testing is used because:

* Behavior emerges from module composition
* Random inputs help explore corner cases
* Structural correctness is validated probabilistically

---

### Comparison of Testing Strategies

| Strategy   | Advantages                  | Disadvantages                        |
| ---------- | --------------------------- | ------------------------------------ |
| Exhaustive | Complete coverage           | Only feasible for small input spaces |
| Sampling   | Efficient for large designs | Rare edge cases may be missed        |
| Random     | Finds unexpected bugs       | Coverage is non-deterministic        |

---

## Lab 3 — Verification

### Exercise 2 Testing Strategy

The state space is too large to test exhaustively. Instead:

* Representative initial states are selected
* The model is simulated for many cycles
* Outputs are checked against expected invariants

This balances confidence with computational feasibility.


### Exercise 3 Testing Strategy

This exercise combines clocked and combinational logic. The testbench:

* Controls reset explicitly
* Advances the clock manually
* Tracks expected state in software
* Verifies correct behavior across clock cycles


### Don’t Care Inputs (Exercise 4)

A “Don’t Care” input indicates the output must be **independent of that input**.

Testing approach:

1. Fix all meaningful inputs
2. Vary the don’t-care input across all values
3. Assert that the output remains unchanged

---

## Lab 4 — Verification Toolchain

### What is a Registry?

A registry is a catalog of packages. It defines where packages are stored and how they are retrieved, typically via a Git repository at a fixed commit or baseline.

---

### What is a Package?

A package is a reusable unit of software, such as:

* Build utilities
* Libraries
* Tooling infrastructure

Examples include `nyu-cmake` and `catch2`.

---

### Interface Library vs Normal Library

**Normal Library / Executable**

* Compiled into object files or binaries
* Produces build artifacts

**Interface Library**

* Produces no compiled output
* Propagates usage requirements (include paths, source files, flags)
* Ideal for:

  * SystemVerilog sources
  * Header-only libraries
  * Parameterized or template-based code

---

### What is a Top Module?

A top module is a SystemVerilog module explicitly exposed to Verilator for simulation. Only top modules:

* Generate C++ simulation models
* Can be directly driven by testbenches

This improves encapsulation and reduces build complexity.

---

## Lab 5 — Advanced SystemVerilog

### `logic` vs `wire`

* `logic` is used for most RTL signals with a single driver
* `wire` is used only when multiple drivers are required
* `reg` is avoided due to confusing legacy semantics

---

### Interfaces and Modports

Interfaces bundle related signals and enforce directionality using modports. They:

* Reduce wiring errors
* Improve readability
* Scale well for complex processor interconnects

---

### Parameterized Modules

Parameterized modules defer decisions such as bit-width until instantiation. This enables:

* Reuse across designs
* Scalable architectures
* Cleaner, more maintainable RTL

---

## Week of October 13, 2025

Project Work:
- Contributed to the group RISC-16 processor project:  
  https://github.com/clavinator7/RISC-16-Processor-Project
- Implemented the Program Counter (`pc.v`) module.
- Implemented and revised the Instruction Memory module based on feedback.
- Attended multiple group meetings (in-person and virtual) to review module interfaces and expected behavior.
- Coordinated Git workflow with teammates, including branching, committing, and merging changes.

Team Contributions:
- **Calvin** implemented the ALU and control module and handled repository configuration and merges.
- **Louai** implemented the register file and developed the data memory testbench, and frequently helped clarify Verilog and testing conventions.
- **I** implemented the Program Counter and Instruction Memory modules and updated them after group review and TA feedback.

What I Learned:
- Learned the importance of understanding the full processor datapath before implementing individual modules.
- Gained experience designing synchronous logic in Verilog, particularly around reset behavior and clocked updates.
- Learned that module-level testing should be done using external testbenches rather than embedding test code inside modules.
- Improved my understanding of collaborative Git workflows and how to avoid integration issues.
- Realized the value of regular communication and reviewing each other’s code to ensure consistency across the design.

Overall, this phase focused on transitioning from understanding the architecture and tools to implementing and integrating core processor modules.
**Collaboration Summary**

---
